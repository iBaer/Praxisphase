\documentclass[12pt]{article}

% language stuff
% \usepackage{ngerman}           % deutsche Überschriften etc.
\usepackage{german}
\usepackage[utf8]{inputenc} % direkte Einbgabe von Umlauten

% Layout-Einstellungen
\usepackage{parskip}          % Abstand statt Einrückung
\frenchspacing                % no extra space after periods
\usepackage{parskip}          % paragraph gaps instead of indentation
\usepackage{times}            % default font Times
\tolerance=9000               % avoid words across right border

% miscellaneous
\usepackage{graphicx}         % graphics
\usepackage{hhline}           % double lines in tables
\usepackage{amsfonts}         % real numbers etc.
\usepackage[rightcaption]{sidecap} % figure captions on the right (optional)
\usepackage{hyperref}         % for URLs
\usepackage{listings}         % for code samples

% Hier bei Bedarf die Seitenränder einstellen
\usepackage{geometry}
%\geometry{a4paper}
\geometry{a4paper,left=25mm,right=25mm, top=3.0cm, bottom=3.0cm} 

% Paragraph Änderung
\usepackage{color,soul}
\usepackage{titlesec}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\vspace*{-10mm}Analyse eines C++-Programms\\ zur Simulation von Mehrphasenströmungen}
\author{
	% Autor und Email-Adresse ersetzen:
	Pascal Bähr
	}

\date{5. April 2016}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle

%-------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------
Zum besseren Verständnis des Programms soll dieses Dokument dienen. Die Funktionalitäten und die verwendeten Datenstrukturen der einzelnen Klassen werden übersichtlich und verständlich erläutert, so dass eine spätere Umstrukturierung des Programms einfacher wird. Es wird zunächst nur die Implementierung für eine Dimension betrachtet.
\end{abstract}



%=============================================================
\section{Ablauf}
Der grobe Ablauf des Programms.
\begin{enumerate}
	\item Auswahl der Methode zur Flußberechnung
	\item Konstruktor Lax\_Friedrich/Force
	\item Konstruktor numerische\_methode
	\item asd
	\item $<Magic>$
\end{enumerate}	

%-------------------------------------------------------------
% default a), b), c) numbering
\renewcommand{\labelenumi}{\alph{enumi})} 

\section{Dateien}
%-------------------------------------------------------------
\subsection{main.cpp}
Dient bisher nur zur Auswahl der Flußberechnungsmethode. \\
Zur Auswahl stehen:
\begin{enumerate}
	\item Lax-Friedrich Methode
	\item FORCE Methode
\end{enumerate}

\subsection{LaxFriedrichMethode.*}
Abgeleitet von der Klasse {\em numerische\_methode}\\
Verwendet Konstruktor der Basisklasse \\
Implementiert die abstrakte Methode {\em calc\_method\_flux()} \\

\subsubsection{calc\_method\_flux()} \label{sssec:laxcalc}
\textcolor{red}{Parameter {\em int dir} warscheinlich unnötig!}
\paragraph{Variablen}
Zunächst Initialisierung einiger Variablen:
\begin{enumerate}
	\item width \& height: Mit Werten der Größe des Rasters
	\item neqs: Anzahl der Gleichungen aus Gleichungssystem-Klasse, bei 1 Dimension -"> 3
	\item *uall/*fall/*gall: 
	\\Allokierung eines Arrays für zusammenhängenden Speicher
	\item ***cs/***f/***g: 
	\\3D-Arrays: neqs X width X height
	\\Mit zusammenhängen Speicher in allen Dimensionen über uall... + Speicherarithmetik
	\item 4-facher Vektor fi: 
	\\ Return Vektor für $F_{i}$ bei der Flussberechnung
	\\ wie a[i][j][k][l]
	\\ i = neqs
	\\ j = Raster Width
	\\ k = Raster Heigth
	\\ l = Dimension, also 1 oder 2
	\\ alle Werte initialisiert mit 0.0
\end{enumerate}

\renewcommand{\labelenumi}{\theenumi.} 
\paragraph{Algorithmus}
Eigentliche Fluss-Berechnung:\\
\begin{enumerate}
	\item U Berechnen durch Gleichungssystemklasse
	\item F Berechnen durch Gleichungssystemklasse
	\item FORCE Fluss $F^{LF}$ berechnen über Gleichung 5.50\\
	\begin{equation}
	F^{LF}_i = \frac{1}{2}\left(F_i^n+F_{i+1}^n \right) + \frac{\Delta x}{2
		\Delta t}\left(U_i^n - U_{i+1}^n \right)\label{eq:fluss_LF}
	\end{equation}
	$F^{LF}_i$ ist eine Iteration über (in Array-Schreibweise): fi[k][i][0][0]\\
	k := 0 bis neqs\\
	i := 0 bis CELLS[0]+ordnung+1\\
	\textcolor{red}{Besser raster.getwidth() - ordnung\\
	??? Die Raster Höhe und die Dimension bei der 1-D Berechnung sind quasi überflüssig.}
	\item Rückgabe des Vektorkonstruktes
\end{enumerate}

\subsection{FORCE.*}
Abgeleitet von der Klasse {\em numerische\_methode}\\
Verwendet Konstruktor der Basisklasse \\
Implementiert die abstrakte Methode {\em calc\_method\_flux()} \\

\subsubsection{calc\_method\_flux()} \label{sssec:forcecalc}
\textcolor{red}{Parameter {\em int dir} warscheinlich unnötig!}
\paragraph{Variablen}
Zunächst Initialisierung einiger Variablen:
\begin{enumerate}
	\item width \& height: Mit Werten der Größe des Rasters
	\item neqs: Anzahl der Gleichungen aus Gleichungssystem-Klasse, bei 1 Dimension -"> 3
	\item *uall/*fall/*gall/*f\_laxall/*f\_rieall/*g\_laxall/*g\_rieall: 
	\\Allokierung eines Arrays für zusammenhängenden Speicher
	\item ***cs/***f/***g/***f\_lax/***f\_rie/***g\_lax/***g\_rie: 
	\\3D-Arrays: neqs X width X height
	\\Mit zusammenhängen Speicher in allen Dimensionen über uall... + Speicherarithmetik
	\item 4-facher Vektor fi: 
	\\ Return Vektor für $F_{FORCE}$ bei der Flussberechnung
	\\ wie a[i][j][k][l]
	\\ i = neqs
	\\ j = Raster Width
	\\ k = Raster Heigth
	\\ l = Dimension, also 1 oder 2
	\\ alle Werte initialisiert mit 0.0
\end{enumerate}

\renewcommand{\labelenumi}{\theenumi.} 
\paragraph{Algorithmus}
Eigentliche Fluss-Berechnung:\\
\begin{enumerate}
	\item U Berechnen durch Gleichungssystemklasse
	\item F Berechnen durch Gleichungssystemklasse
	\item Lax-Friedrichs Fluss $F^{LF}$ berechnen über Gleichung 5.50\\
	\begin{equation}
	F^{LF}_i = \frac{1}{2}\left(F_i^n+F_{i+1}^n \right) + \frac{\Delta x}{2
		\Delta t}\left(U_i^n - U_{i+1}^n \right)\label{eq:fluss_LF}
	\end{equation}
	$F^{LF}_i$ ist eine Iteration über (in Array-Schreibweise): fi[k][i][0][0]\\
	k := 0 bis neqs\\
	i := 0 bis CELLS[0]+ordnung+1\\
	\textcolor{red}{Besser -$>$ raster.getwidth() - ordnung\\
	Fluss wird ein zweites mal über eine Vektor Länge (aus Gleichungssystem) berechnet, wahrscheinlich ein Artefakt!}
	\item Richtmeyer Vektor U $U^{RI}$ (als Raster aufgebaut) berechnen über Gleichung 5.53\\
	\begin{equation}
	U^{RI}_{i+1/2} = \frac{1}{2}\left[U_i^n + U_{i+1}^n\right] + \frac{\Delta t}{2
		\Delta x}\left(F_{i}^n - F_{i+1}^n \right) \label{eq:fluss_RI}
	\end{equation}
	Jeweils für jede Zelle: d (Dichte), ux (Geschwindigkeit in x-Richtung), uxr (Relative Geschwindigkeit in x-Richtung)\\
	Von Vektor U aus Gleichung 5.24:
	\[
	U =  \left[\begin{array}{c}\rho \\ \rho u \\ u_r\end{array}\right]
	\]
	bzw im Programm für die Werte der Zelle:
	\[
	U =  \left[\begin{array}{c}\rho \\ \frac{\rho u}{\rho} \\ u_r\end{array}\right]
	=  \left[\begin{array}{c}\rho \\ u \\ u_r\end{array}\right]
	=>  \left[\begin{array}{c}d \\ ux \\ uxr\end{array}\right]
	\]
	
	zusätzlich den Druck p (Druck) pro Zelle über Gleichung 5.15\\
	\begin{equation}
	P = K_g \rho^{\gamma},\label{eq:druck_rho}
	\end{equation}
	\item Richtmeyer Fluss $F^{RI}$ berechnen durch Gleichungssystemklasse bzw Gleichung 5.54\\
	\begin{equation}
	F^{RI}_{i+1/2} = F(U^{RI}_{i+1/2}) .
	\end{equation}\\
	\item FORCE Fluss $F^{FORCE}$ berechnen durch Mittelwert Berechnung zwischen den zwei Flüssen. Gleichung 5.55\\
	\begin{equation}
	F^{FORCE}_{i+1/2} = \frac{1}{2}\left[ F^{LF}_{i+1/2} +  F^{RI}_{i+1/2} \right]
	\end{equation}
	Gespeichert in f\_force Vektor
	\item Rückgabe des Vektorkonstruktes
\end{enumerate}

\renewcommand{\labelenumi}{\alph{enumi})} 
\subsection{numerische\_methode.cpp}
Basisklasse für die spezialisierten Flußberechnungsmethoden.\\
\subsubsection{Konstruktor} \label{sssec:numkons}
\paragraph{Variablen}
Zunächst Initialisierung einiger Variablen durch auslesen aus Werten der Konstanten.\\
\textcolor{red}{Konstanten Klasse hat keinen höheren Nutzen insbesondere als Attribut?!}
\begin{enumerate}
	\item name: für Protokollierung mit write() \ref{sssec:write} zur Unterscheidung zwischen Lax-Friedrich und FORCE Methode
	\item ordnung: Ordnung des Verfahrens / \textcolor{red}{Wie viele zusätzliche Zellen an den Rändern miteinbezogen werden} /  bisher nur 1 implementiert
	\item dimension: Dimension in der gerechnet wird. Bisher 1D (x) und 2D (x,y)
	\item CELLS: Zeigt Anzahl der Zellen in entsprechender Dimension\\
	CELLS[0] für Zellen in X; CELLS[1] für Zellen in Y
	\item cref: Konstante in Equation of States; K$_2$
	\item done: Dichte der Phase 1; $\rho_1$
	\item ccl: Massenanteil in Simulation
	\textcolor{red}{\item mor: x-Wert rechte Grenze - oben rechts
	\item mol: x-Wert linke Grenze - oben links
	\item mur: y-Wert untere Grenze - unten rechts
	\item mul: y-Wert obere Grenze - unten links}
	\item timeou: Zeit Output - maximale Zeit als Abbruchbedingung
	\item steps: Zum Festhalten der gemachten Schritte zur Protokollierung
	\item maxnt: Gesetztes Maximum als Abbruchbedingung bei Fehler
	\item teilerend: für wieviel Schritte dt geteilt wird
	\item teiler: um wieviel dt zuerst geteilt wird\\
	klein Anfang für Stabilität
	\item variante: Variante der EOS \\andere varianten nicht getestet
	\item g: Gamma Konstante für EOS
	\item dx: Delta x ((rechter Rand-linker Rand)/Anzahl Zellen in x) / dy: Delta y
	\item dt: Delta t bei Berechnung des Time Steps mit CFL\\
	\textcolor{red}{zum Debuggen mit 0 initialisiert, sonst nicht vorher in Verwendung}
	\item rhol: Initialwert der Dichte der Phase 2, links
	\item alfll: Alpha-Berechnung (Volumenanteil) über 
	\[
	\alpha = 1 - \rho/\rho_1 + c\rho/\rho_1
	\]
	bzw im Programm
	\[
	alfll = 1.0 - rhol/done + ccl*rhol/done
	\]
	\textcolor{red}{eigentlich unnötig, da nur für den nächsten Schritt benötigt wird}
	\item dll: Berechnung von Dichte $\rho_2$ über
	\[
	\rho_2 = (c\rho)/\alpha,
	\]
	bzw im Programm
	\[
	dll = ccl*rhol/alfll
	\]
	\textcolor{red}{eigentlich unnötig, da nur für den nächsten Schritt benötigt wird}
	\item pll: Berechnung von Druck $P$ über
	\[
	P = K_2\rho_2^\gamma
	\]
	bzw im Programm
	\[
	pll = cref*dll^g
	\]
	\textcolor{red}{eigentlich unnötig, da nur für den nächsten Schritt benötigt wird}
	\item ct: Berechnung der CT bzw $K_g$ Größe über (Umformung von Gleichung 5.15)
	\[
	K_g = \frac{P}{\rho^g}
	\]
	bzw im Programm
	\[
	ct = \frac{pll}{rhol^g}
	\]
	\item splitting: Ob mit Unsplitting oder Splitting gerechnet werden soll
\end{enumerate}
\paragraph{Funktion}
Der Konstruktor lässt entscheiden, ob mit splitting oder unsplitting gerechnet wird.\\
\textcolor{red}{Könnte Teil der Main Funktion werden}
\subsubsection{start\_method()} \label{sssec:start}
\paragraph{Variablen}
\begin{enumerate}
	\item time: Variable für den Timestep (über cflcon() \ref{sssec:cflc})\\
	startet bei 0.0
	\item timetol: Untere Grenze für die Zeit
	\item timedif: Nach jedem Berechnungsschritt aktualisiert auf $|time-timeou|$
	\item step\_output: Gibt an ob Zwischenschritte protokolliert werden sollen
\end{enumerate}
\paragraph{Funktion}
\renewcommand{\labelenumi}{\theenumi.}
\begin{enumerate}
	\item Abfrage ob Updates mit Splitting oder Unsplitting kalkuliert werden sollen\\
	\textcolor{red}{Was???}
	\item (Eventuell protokollieren)
	\item Schleife läuft bis zu einem Maximum maxnt, damit es bspw im Fehlerfall nicht unendlich läuft\\
	und solange timedif $>$ timetol
	\begin{enumerate}
	\item Setzen der Rand- und Anfangswertbedingungen im Raster über die Rasterfunktion: bcondi()
	\item (Eventuell protokollieren)
	\item Zeitschritt berechnen über Funktion cflcon() \ref{sssec:cflc}
	\item Falls Splitting, dann update() \ref{sssec:upd} mit entsprechender Flussberechnungsmethode (\ref{sssec:laxcalc} oder \ref{sssec:forcecalc}) und Parameter dir = 1
	\item Falls Unsplitting, dann update() mit Flußberechnung und Parameter dir = 1\\
	neue Setzung der Boundary Conditions (bcondi() \ref{sssec:bdcondi})\\
	Erneutes Update mit Parameter dir = 2
	\item timedif setzen auf 
	\begin{equation}
	|time-timeou|
	\end{equation}
	\item Variable steps auf n erhöhen für Protokollierung
	\end{enumerate}
	\item (Eventuell protokollieren)
\end{enumerate} 

\subsubsection{cflcon()} \label{sssec:cflc}
Berechnung des nächsten Zeitschrittes über die CFL-Condition.

\renewcommand{\labelenumi}{\alph{enumi})} 
\paragraph{Variablen}
\begin{enumerate}
	\item cref: Wie \ref{sssec:numkons}\\
	\textcolor{red}{Wird hier noch mal instanziert, könnte anders mit Konstanten gelöst werden}
	\item cfl:  CFL Condition aus Konstanten
	\item ccl: Wie \ref{sssec:numkons}\\
	\textcolor{red}{Wird hier noch mal instanziert, könnte anders mit Konstanten gelöst werden}
	\item done: Wie \ref{sssec:numkons}\\
	\textcolor{red}{Wird hier noch mal instanziert, könnte anders mit Konstanten gelöst werden}
	\item gi: invertierte Gamma Konstante $\gamma^{-1}=\frac{1}{\gamma}$
	\item maxd: Bekommt Dichte aus Zellen zugewiesen \\
	\textcolor{red}{Nur für analytische Methode, kaum Funktion}
	\item maxu: Bekommt x-Geschwindigkeit aus Zellen zugewiesen \\
	\textcolor{red}{Nur für analytische Methode, kaum Funktion}
	\item maxur: Bekommt Relative x-Geschwindigkeit aus Zellen zugewiesen \\
	\textcolor{red}{Nur für analytische Methode, kaum Funktion}
	\item maxuy: Bekommt y-Geschwindigkeit aus Zellen zugewiesen \\
	\textcolor{red}{Nur für analytische Methode, kaum Funktion}
	\item maxuyr: Bekommt Relative y-Geschwindigkeit aus Zellen zugewiesen \\
	\textcolor{red}{Nur für analytische Methode, kaum Funktion}
	\item smax: Höchster Eigenwert als v$_{max}$ für Gleichung 2.19 bzw Ungleichung 2.20
	\item maxs: Kalkulierter Eigenwert zum überprüfen auf Maximum mit smax
	\item n\_eqns: Anzahl der Formeln in Datei 'formeln' in einer Zeile
	\item uone: Ergebnis des 1. Wertes von Vektor U\\
	\[
	U =  \left[\begin{array}{c}\rho \\ \rho u \\ u_r\end{array}\right]
	\]
	\item utwo: Ergebnis des 2. Wertes aus Vektor U
	\item uthree: Ergebnis des 3. Wertes aus Vektor U
	\item ufour: Ergebnis des 4. Wertes aus Vektor U für 2D\\
	\[
	U = \left[\begin{array}{c}\rho \\ \rho u_x \\ \rho u_y \\ u_{r,x}
	\\ u_{r,y} \end{array}\right]
	\]
	\item ufive: Ergebnis des 5. Wertes aus Vektor U für 2D
	\item p: Druck / ux: x-Geschw / d: Dichte $\rho$ / uxr: x-rel Geschw / dtwo: Dichte der Phase 2; $\rho_2$ / uy: y-Geschw / uyr: y-rel. Geschw\\
	für Kalkulationen
\end{enumerate}

\paragraph{Funktion}
\renewcommand{\labelenumi}{\theenumi.} 
\begin{enumerate}
	\item Passende Methode gewählt, je nach Dimension und Analytische Lösung (Konstante calceigv = 0) oder über Jacobi Matrix (= 1)
	\item[-] Weitere Schritte nur für 1D und Jacobi analysiert
	\item Anlegen von Vektoren und Matrix mit Lapack++
	\item Maxima finden von 0 bis CELLS[0]+2*ordnung+1\\
	\textcolor{red}{Eventuell auch über Raster Weite statt mit CELLS}
	\begin{enumerate}
		\item asd
	\end{enumerate}
\end{enumerate}

\subsubsection{update()} \label{sssec:upd}
\paragraph{Variablen}

\paragraph{Funktion}

\subsubsection{write()} \label{ssec:write}
\paragraph{Variablen}

\paragraph{Funktion}

\subsection{raster.*}
\subsubsection{write()} \label{sssec:write}
\paragraph{Variablen}

\paragraph{Funktion}

\section{Umstrukturierung - Ideen}
%-------------------------------------------------------------
\subsection{Variablennamen}
Sämtliche Variablen sollten in einem einheitlichen und vor allem {\em lesbaren} Stil benannt werden. \\
Entweder deutsche oder englische Bezeichner!

\end{document}

